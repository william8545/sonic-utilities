"""
This CLI plugin was auto-generated by using 'sonic-cli-gen' utility
"""

import click
import tabulate
import json
import utilities_common.cli as clicommon
import utilities_common.multi_asic as multi_asic_util
from sonic_py_common import multi_asic
from utilities_common import constants

from utilities_common.switch_hash import (
    CFG_SWITCH_HASH,
    STATE_SWITCH_CAPABILITY,
    SW_CAP_HASH_FIELD_LIST_KEY,
    SW_CAP_ECMP_HASH_ALGORITHM_KEY,
    SW_CAP_LAG_HASH_ALGORITHM_KEY,
    SW_CAP_ECMP_HASH_CAPABLE_KEY,
    SW_CAP_LAG_HASH_CAPABLE_KEY,
    SW_CAP_ECMP_HASH_ALGORITHM_CAPABLE_KEY,
    SW_CAP_LAG_HASH_ALGORITHM_CAPABLE_KEY,
    SW_HASH_KEY,
    SW_CAP_KEY,
)

#
# Hash helpers --------------------------------------------------------------------------------------------------------
#

def format_attr_value(entry, attr):
    """ Helper that formats attribute to be presented in the table output.

    Args:
        entry (Dict[str, str]): CONFIG DB entry configuration.
        attr (Dict): Attribute metadata.

    Returns:
        str: formatted attribute value.
    """

    if attr["is-leaf-list"]:
        value = entry.get(attr["name"], [])
        return "\n".join(value) if value else "N/A"
    return entry.get(attr["name"], "N/A")

#
# Hash CLI ------------------------------------------------------------------------------------------------------------
#

@click.group(
    name="switch-hash",
    cls=clicommon.AliasedGroup
)
@multi_asic_util.multi_asic_click_option_namespace
@click.pass_context
def SWITCH_HASH(ctx, namespace):
    """ Show switch hash feature configuration """
    pass


@SWITCH_HASH.command(
    name="global"
)
@click.option(
    "-j", "--json", "json_format",
    help="Display in JSON format",
    is_flag=True,
    default=False
)
@clicommon.pass_db
@click.pass_context
def SWITCH_HASH_GLOBAL(ctx, db, json_format):
    """ Show switch hash global configuration """

    namespace = ctx.parent.params['namespace']
    ns_list = multi_asic.get_namespace_list(namespace)

    for idx, ns in enumerate(ns_list):
        cfgdb = db.cfgdb_clients.get(ns, db.cfgdb)

        if multi_asic.is_multi_asic() and not namespace:
            if idx > 0:
                click.echo()
            if ns != constants.DEFAULT_NAMESPACE:
                click.echo("Namespace {}:".format(ns))

        header = [
            "Hash",
            "Configuration",
        ]
        body = []

        sub_header = [
            "Hash Field",
            "Algorithm"
        ]
        ecmp_body = []
        lag_body = []

        table = cfgdb.get_table(CFG_SWITCH_HASH)
        entry = table.get(SW_HASH_KEY, {})

        if not entry:
            click.echo("No configuration is present in CONFIG DB")
            if not multi_asic.is_multi_asic() or namespace:
                ctx.exit(0)
            continue

        if json_format:
            json_dict = {
                "ecmp": {
                    "hash_field": entry["ecmp_hash"] if "ecmp_hash" in entry else "N/A",
                    "algorithm": entry["ecmp_hash_algorithm"] if "ecmp_hash_algorithm" in entry else "N/A"
                },
                "lag": {
                    "hash_field": entry["lag_hash"] if "lag_hash" in entry else "N/A",
                    "algorithm": entry["lag_hash_algorithm"] if "lag_hash_algorithm" in entry else "N/A"
                }
            }
            click.echo(json.dumps(json_dict, indent=4))
            if not multi_asic.is_multi_asic() or namespace:
                ctx.exit(0)
            continue

        ecmp_row = [
            format_attr_value(
                entry,
                {
                    'name': 'ecmp_hash',
                    'is-leaf-list': True
                }
            ),
            format_attr_value(
                entry,
                {
                    'name': 'ecmp_hash_algorithm',
                    'is-leaf-list': False
                }
            ),
        ]
        ecmp_body.append(ecmp_row)

        lag_row = [
            format_attr_value(
                entry,
                {
                    'name': 'lag_hash',
                    'is-leaf-list': True
                }
            ),
            format_attr_value(
                entry,
                {
                    'name': 'lag_hash_algorithm',
                    'is-leaf-list': False
                }
            ),
        ]
        lag_body.append(lag_row)

        body.append(["ECMP", tabulate.tabulate(ecmp_body, sub_header, "psql")])
        body.append(["LAG", tabulate.tabulate(lag_body, sub_header, "psql")])

        click.echo(tabulate.tabulate(body, header, "grid"))


@SWITCH_HASH.command(
    name="capabilities"
)
@click.option(
    "-j", "--json", "json_format",
    help="Display in JSON format",
    is_flag=True,
    default=False
)
@clicommon.pass_db
@click.pass_context
def SWITCH_HASH_CAPABILITIES(ctx, db, json_format):
    """ Show switch hash capabilities """

    namespace = ctx.parent.params['namespace']
    ns_list = multi_asic.get_namespace_list(namespace)

    for idx, ns in enumerate(ns_list):
        state_db = db.db_clients.get(ns, db.db)

        if multi_asic.is_multi_asic() and not namespace:
            if idx > 0:
                click.echo()
            if ns != constants.DEFAULT_NAMESPACE:
                click.echo("Namespace {}:".format(ns))

        header = [
            "Hash",
            "Capabilities",
        ]
        body = []

        sub_header = [
            "Hash Field",
            "Algorithm"
        ]
        ecmp_body = []
        lag_body = []

        entry = state_db.get_all(state_db.STATE_DB, "{}|{}".format(STATE_SWITCH_CAPABILITY, SW_CAP_KEY))

        if not entry:
            if not multi_asic.is_multi_asic() or namespace:
                ctx.fail("No data is present in STATE DB")
            continue

        entry.setdefault(SW_CAP_HASH_FIELD_LIST_KEY, 'N/A')
        entry.setdefault(SW_CAP_ECMP_HASH_ALGORITHM_KEY, 'N/A')
        entry.setdefault(SW_CAP_LAG_HASH_ALGORITHM_KEY, 'N/A')
        entry.setdefault(SW_CAP_ECMP_HASH_CAPABLE_KEY, 'false')
        entry.setdefault(SW_CAP_LAG_HASH_CAPABLE_KEY, 'false')
        entry.setdefault(SW_CAP_ECMP_HASH_ALGORITHM_CAPABLE_KEY, 'false')
        entry.setdefault(SW_CAP_LAG_HASH_ALGORITHM_CAPABLE_KEY, 'false')

        if not entry[SW_CAP_HASH_FIELD_LIST_KEY]:
            entry[SW_CAP_HASH_FIELD_LIST_KEY] = "no capabilities"

        if not entry[SW_CAP_ECMP_HASH_ALGORITHM_KEY]:
            entry[SW_CAP_ECMP_HASH_ALGORITHM_KEY] = "no capabilities"

        if not entry[SW_CAP_LAG_HASH_ALGORITHM_KEY]:
            entry[SW_CAP_LAG_HASH_ALGORITHM_KEY] = "no capabilities"

        if json_format:
            if entry[SW_CAP_HASH_FIELD_LIST_KEY] not in ["N/A", "no capabilities"]:
                entry[SW_CAP_HASH_FIELD_LIST_KEY] = entry[SW_CAP_HASH_FIELD_LIST_KEY].split(',')

            if entry[SW_CAP_ECMP_HASH_ALGORITHM_KEY] not in ["N/A", "no capabilities"]:
                entry[SW_CAP_ECMP_HASH_ALGORITHM_KEY] = entry[SW_CAP_ECMP_HASH_ALGORITHM_KEY].split(',')

            if entry[SW_CAP_LAG_HASH_ALGORITHM_KEY] not in ["N/A", "no capabilities"]:
                entry[SW_CAP_LAG_HASH_ALGORITHM_KEY] = entry[SW_CAP_LAG_HASH_ALGORITHM_KEY].split(',')

            ecmp_hash_field = (
                entry[SW_CAP_HASH_FIELD_LIST_KEY]
                if entry[SW_CAP_ECMP_HASH_CAPABLE_KEY] == 'true'
                else 'not supported'
            )
            ecmp_algorithm = (
                entry[SW_CAP_ECMP_HASH_ALGORITHM_KEY]
                if entry[SW_CAP_ECMP_HASH_ALGORITHM_CAPABLE_KEY] == 'true'
                else 'not supported'
            )
            lag_hash_field = (
                entry[SW_CAP_HASH_FIELD_LIST_KEY]
                if entry[SW_CAP_LAG_HASH_CAPABLE_KEY] == 'true'
                else 'not supported'
            )
            lag_algorithm = (
                entry[SW_CAP_LAG_HASH_ALGORITHM_KEY]
                if entry[SW_CAP_LAG_HASH_ALGORITHM_CAPABLE_KEY] == 'true'
                else 'not supported'
            )
            json_dict = {
                "ecmp": {
                    "hash_field": ecmp_hash_field,
                    "algorithm": ecmp_algorithm
                },
                "lag": {
                    "hash_field": lag_hash_field,
                    "algorithm": lag_algorithm
                }
            }
            click.echo(json.dumps(json_dict, indent=4))
            if not multi_asic.is_multi_asic() or namespace:
                ctx.exit(0)
            continue

        entry[SW_CAP_HASH_FIELD_LIST_KEY] = entry[SW_CAP_HASH_FIELD_LIST_KEY].split(',')
        entry[SW_CAP_ECMP_HASH_ALGORITHM_KEY] = entry[SW_CAP_ECMP_HASH_ALGORITHM_KEY].split(',')
        entry[SW_CAP_LAG_HASH_ALGORITHM_KEY] = entry[SW_CAP_LAG_HASH_ALGORITHM_KEY].split(',')

        ecmp_row = [
            format_attr_value(
                entry,
                {
                    'name': SW_CAP_HASH_FIELD_LIST_KEY,
                    'is-leaf-list': True
                }
            ) if entry[SW_CAP_ECMP_HASH_CAPABLE_KEY] == 'true' else 'not supported',
            format_attr_value(
                entry,
                {
                    'name': SW_CAP_ECMP_HASH_ALGORITHM_KEY,
                    'is-leaf-list': True
                }
            ) if entry[SW_CAP_ECMP_HASH_ALGORITHM_CAPABLE_KEY] == 'true' else 'not supported',
        ]
        ecmp_body.append(ecmp_row)

        lag_row = [
            format_attr_value(
                entry,
                {
                    'name': SW_CAP_HASH_FIELD_LIST_KEY,
                    'is-leaf-list': True
                }
            ) if entry[SW_CAP_LAG_HASH_CAPABLE_KEY] == 'true' else 'not supported',
            format_attr_value(
                entry,
                {
                    'name': SW_CAP_LAG_HASH_ALGORITHM_KEY,
                    'is-leaf-list': True
                }
            ) if entry[SW_CAP_LAG_HASH_ALGORITHM_CAPABLE_KEY] == 'true' else 'not supported',
        ]
        lag_body.append(lag_row)

        body.append(["ECMP", tabulate.tabulate(ecmp_body, sub_header, "psql")])
        body.append(["LAG", tabulate.tabulate(lag_body, sub_header, "psql")])

        click.echo(tabulate.tabulate(body, header, "grid"))


def register(cli):
    """ Register new CLI nodes in root CLI.

    Args:
        cli (click.core.Command): Root CLI node.
    Raises:
        Exception: when root CLI already has a command
                   we are trying to register.
    """
    cli_node = SWITCH_HASH
    if cli_node.name in cli.commands:
        raise Exception(f"{cli_node.name} already exists in CLI")
    cli.add_command(SWITCH_HASH)
